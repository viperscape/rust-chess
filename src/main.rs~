#[derive(Show,Copy)]
enum Item {
    Pawn,
    King,
    Queen,
    Rook,
    Knight, 
    Bishop,
}

type Position = (usize,usize);

impl Item {
    fn play_isvalid (&self, from:Position, to:Position, inverted:bool) -> bool {
        match *self {
            Item::Pawn => { 
                if to.0 - from.0 == 1 &&
                    to.1 - from.1 == 1 {true}
                else {false}
            },
            Item::King => {true},
            Item::Queen => {true},
            Item::Rook => {true},
            Item::Knight => {true},
            Item::Bishop => {true},
        }
    }
}

#[derive(Show,Copy)]
enum Player {
    Black(Item),
    White(Item),
}

impl Player {

    /// check play logic for valid moves
    fn play_isvalid (&self, from: Position , to: Position) -> bool {
        match *self {
            Player::Black(item) => item.play_isvalid(from,to,true),
            Player::White(item) => item.play_isvalid(from,to,false),
        }
    }
}


type BoardLayout = [[Option<Player>;8];8];

#[derive(Show,Copy)]
struct Board(BoardLayout);

impl Board {
    fn new() -> Board  {
        let mut board = [[None;8];8];

        //setup pawns row
        board[1] = [Some(Player::White(Item::Pawn));8];
        board[6] = [Some(Player::Black(Item::Pawn));8];

        //setup home row
        board[0] = [Some(Player::White(Item::Rook)),
                    Some(Player::White(Item::Knight)),
                    Some(Player::White(Item::Bishop)),
                    Some(Player::White(Item::Queen)),
                    Some(Player::White(Item::King)),
                    Some(Player::White(Item::Bishop)),
                    Some(Player::White(Item::Knight)),
                    Some(Player::White(Item::Rook))];

        board[7] = [Some(Player::Black(Item::Rook)),
                    Some(Player::Black(Item::Knight)),
                    Some(Player::Black(Item::Bishop)),
                    Some(Player::Black(Item::Queen)),
                    Some(Player::Black(Item::King)),
                    Some(Player::Black(Item::Bishop)),
                    Some(Player::Black(Item::Knight)),
                    Some(Player::Black(Item::Rook))];
        Board(board)
    }

    fn get_player (&self,at:Position) -> &[Player] {
        self.0[at.0][at.1].as_slice()
    }

    fn play(&mut self, from:Position,to:Position)-> bool {
        println!("{:?}",self.get_player(from));
        println!("{:?}",self.get_player(to));
        true
    }
}

fn main() {
    let mut board = Board::new();
   // println!("{:?}",board);
    board.play((0,1),(6,3));
}
